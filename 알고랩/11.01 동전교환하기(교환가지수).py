"""
거스름 돈을 동전으로 교환할 때, 동전을 교환하는 가지수를 찾는 프로그램을 작성

n = 4 // 거슬러 줄 돈
m = 3   // 동전의 개수
coin = [1, 2, 3] // 동전의 타입

해당 문제도 DP를 통해 해결한다.

dp[i][j] = j원 일때, i가지 타입의 동전으로 교환하는 방법의 가지 수
    dp[3][10] = 4 라면, 3가지 동전타입(1,2,3)가지고, 10원을 나타낼 수 있는 가지의 수가 4라는 의미이다.

따라서 DP의 크기는 dp.shape = (m+1, n+1)
우리가 구해야 하는 값은 dp[m][n]이다.

dp = [[1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]]
초기 DP는 위 처럼 초기화 한다.

0행은 0원으로 j금액을 만드는 경우의 수인데, 0원으로 0원을 만들 경우만 1이고 나머지는 0이다.

1행은 1원으로 j금액을 만드는 경우의 수인데, 1원으로는 모두 1가지이므로 모두 1이다.
dp = [[1, 0, 0, 0, 0],
      [1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]]
단, dp[1][0]은 1원으로 0원을 만드는 경우는 아무것도 안하는 경우 1가지이므로 1이다.

지금부터가 중요하다.
2행은 2가지(1원, 2원) 종류의 동전으로 j 금액을 만드는 경우의 수이다.
1,2원 동전으로 0원을 만드는 경우를 가정해 보자(dp[2][0])
    1,2원으로는 0원을 만드는 경우는 아무것도 안하는 경우이므로 1이다.

그렇다면 dp[2][1]은 어떤가
    2가지 종류의 동전으로 1원을 만드는 경우는 1원으로 1원을 만드는 경우이다.
    즉 dp[2][1] = dp[1][1]이다.

다음으로, dp[2][2]는...
    2가지 종류의 동전으로 2원을 만드는 경우인데, 1와 2개 / 2원 1개 총 2가지 경우의 수가 있다.
    즉 dp[2][2] = dp[1][2] + dp[2][0]
        => dp[2][2]는 0원에 2원을 추가하여 2원을 만든 경우와, 1원에 1원을 추가하여 2원을 만든 경우 2가지이다.

다음으로, dp[2][3]은,,,
    2가지 종류의 동전으로 3원을 만드는 경우이다. 1원 1개 2원 1개 / 1원 3개 총 2가지 경우의 수가 있다.
    1원에 2원을 추가하여 3원을 만들거나, 1원 2개에 또 1원을 추가해 1원 3개로 3원을 만드는 경우이다.
    즉, dp[2][3] = dp[1][3]+dp[2][1]

또, dp[2][4]는,,,
    2가지 종류의 동전으로 4원을 만드는 경우이다. 1원 4개 / 2원 2개 / 1원 2개 2원 1개 총 3가지의 경우의 수가 있다.
    2원 1개에 1원 2개를 추가하여 4원을 만들거나, 2원 1개에 2원 1개를 추가해 4원을 만들거나, 1원 4개로 4원을 만들거나이다.
    즉, dp[2][4] = dp[2][2] + dp[1][4](2+1)

규칙을 찾아보면, dp[2][j] = d[1][j]                (if  0<=j<coin[2-1](=2))
                       = dp[2][j-2] + dp[1][j]   (if j >= coin[2-1](=2))

따라서,
dp[i][j] = dp[i-1][j]                       (if 0 <= j < cost[i-1])
         = dp[i][j-cost[i-1]] + dp[i-1][j]  (if j >= cost[i-1]

https://withhamit.tistory.com/333
"""
def display(dp):
    for d in dp:
        print(d)

def calc(n, m, coin):
    dp = [[0 for _ in range(n+1)] for __ in range(m+1)]
    dp[0][0] = 1
    for i in range(1, m+1):
        c = coin[i-1]
        for j in range(n+1):
            if j < c:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = dp[i][j-c] + dp[i-1][j]

    display(dp)
    return dp[-1][-1]

def solution(n, m, coin):
    answer = calc(n, m, coin)
    return answer

t = int(input())
for i in range(t):
    n = int(input())
    tmp = list(map(int, input().split(' ')))
    m, coin = tmp[0], tmp[1:]
    print(solution(n, m, coin))